package dev.krishna.weatherappmvi.data.locationimport android.Manifestimport android.app.Applicationimport android.content.Contextimport android.content.pm.PackageManagerimport android.location.Locationimport android.location.LocationManagerimport androidx.core.content.ContextCompatimport com.google.android.gms.location.FusedLocationProviderClientimport dev.krishna.weatherappmvi.domain.location.LocationTrackerimport kotlinx.coroutines.suspendCancellableCoroutineimport javax.inject.Injectimport kotlin.coroutines.resumeclass DefaultLocationTracker @Inject constructor(    private val locationClient: FusedLocationProviderClient,    private val application: Application): LocationTracker {    override suspend fun getCurrentLocation(): Location? {        val hasAccessFineLocationPermission = ContextCompat.checkSelfPermission(            application,            Manifest.permission.ACCESS_FINE_LOCATION        ) == PackageManager.PERMISSION_GRANTED        val hasCoarseFineLocationPermission = ContextCompat.checkSelfPermission(            application,            Manifest.permission.ACCESS_COARSE_LOCATION        ) == PackageManager.PERMISSION_GRANTED        val locationManager = application.getSystemService(Context.LOCATION_SERVICE) as LocationManager        val isGpsEnabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER) ||                locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)        if (!hasAccessFineLocationPermission || !hasCoarseFineLocationPermission || !isGpsEnabled) {            return null        }/** We have two location helper libs in Android. * Location Manager -> The classic old way of getting location. Here we get an object of * LocationManager and implement the locationListener and call requestLocationUpdates to get changes * FusedLocationProviderClient -> It is part of GooglePlayServices and work with mobiles that have * GooglePlayServices enabled. Its the recommended way of getting location as it is quite helpful * in saving battery and increased performance.*/        return suspendCancellableCoroutine { cont->            locationClient.lastLocation.apply {                if (isComplete){                    if (isSuccessful){                        cont.resume(result)                    }else{                        cont.resume(null)                    }                    return@suspendCancellableCoroutine                }                addOnSuccessListener {                    cont.resume(it)                }                addOnFailureListener {                    cont.resume(null)                }                addOnCanceledListener {                    cont.cancel()                }            }        }    }}